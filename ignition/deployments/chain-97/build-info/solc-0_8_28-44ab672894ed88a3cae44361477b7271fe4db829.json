{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-44ab672894ed88a3cae44361477b7271fe4db829",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/BlockchainBounty.sol": "project/contracts/BlockchainBounty.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/BlockchainBounty.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\n/**\n * @title BlockchainBounty\n * @dev A decentralized escrow platform for crypto bounty hunting\n * Allows users to create bounties, submit work, and distribute prizes to winners\n */\ncontract BlockchainBounty {\n    // Enums\n    enum BountyCategory {\n        Content,\n        Design,\n        Development,\n        SmartContract,\n        SocialMedia,\n        FullStack\n    }\n\n    // Structs\n    struct Bounty {\n        uint256 id;\n        address creator;\n        uint256 stakeAmount;\n        uint256 deadline;\n        string description;\n        BountyCategory category;\n        bool isActive;\n        bool isClosed;\n        uint256 totalSubmissions;\n    }\n\n    struct Submission {\n        uint256 bountyId;\n        address submitter;\n        string submissionLink; // Link to the submission (required)\n        string tweetLink; // Tweet link (optional)\n        string githubLink; // GitHub repository link (required)\n        string twitterLink; // Project Twitter link (required)\n        string videoLink; // Video trailer link (required)\n        string indieFunLink; // Indie.fun page link (required)\n        string projectLink; // Live project link (optional)\n        uint256 submissionTime;\n        bool isWinner;\n        uint8 rank; // 0 = not ranked, 1 = 1st place, 2 = 2nd place, 3 = 3rd place\n    }\n\n    struct Winner {\n        address winner;\n        uint8 rank;\n        uint256 prizeAmount;\n    }\n\n    // State variables\n    uint256 public bountyCounter;\n    mapping(uint256 => Bounty) public bounties;\n    mapping(uint256 => mapping(uint256 => Submission)) public submissions; // bountyId => submissionId => Submission\n    mapping(uint256 => uint256) public submissionCounters; // bountyId => submissionCount\n    mapping(uint256 => Winner[]) public winners; // bountyId => winners array\n    mapping(uint256 => mapping(address => bool)) public hasSubmitted; // bountyId => address => hasSubmitted\n    mapping(BountyCategory => uint256[]) public bountiesByCategory; // category => bountyIds array\n\n    // Events\n    event BountyCreated(\n        uint256 indexed bountyId,\n        address indexed creator,\n        uint256 stakeAmount,\n        uint256 deadline,\n        string description,\n        BountyCategory category\n    );\n    \n    event WorkSubmitted(\n        uint256 indexed bountyId,\n        uint256 indexed submissionId,\n        address indexed submitter,\n        string submissionLink,\n        string githubLink,\n        string twitterLink,\n        string videoLink,\n        string indieFunLink\n    );\n    \n    event WinnersSelected(\n        uint256 indexed bountyId,\n        address[] winners,\n        uint8[] ranks,\n        uint256[] prizeAmounts\n    );\n    \n    event BountyClosed(uint256 indexed bountyId, address indexed creator);\n    event BountyCancelled(uint256 indexed bountyId, address indexed creator, string reason);\n    event PrizeDistributed(\n        uint256 indexed bountyId,\n        address indexed winner,\n        uint8 rank,\n        uint256 amount\n    );\n\n    // Modifiers\n    modifier onlyBountyCreator(uint256 _bountyId) {\n        require(\n            bounties[_bountyId].creator == msg.sender,\n            \"Only bounty creator can perform this action\"\n        );\n        _;\n    }\n\n    modifier bountyExists(uint256 _bountyId) {\n        require(bounties[_bountyId].creator != address(0), \"Bounty does not exist\");\n        _;\n    }\n\n    modifier bountyIsActive(uint256 _bountyId) {\n        require(bounties[_bountyId].isActive, \"Bounty is not active\");\n        require(!bounties[_bountyId].isClosed, \"Bounty is already closed\");\n        require(block.timestamp < bounties[_bountyId].deadline, \"Bounty deadline has passed\");\n        _;\n    }\n\n    modifier deadlinePassed(uint256 _bountyId) {\n        require(\n            block.timestamp >= bounties[_bountyId].deadline,\n            \"Bounty deadline has not passed yet\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Create a new bounty with staked amount\n     * @param _description Description of the bounty/project\n     * @param _deadline Unix timestamp for the deadline\n     * @param _category Category of the bounty (Content, Design, Development, SmartContract, SocialMedia, FullStack)\n     */\n    function createBounty(\n        string memory _description,\n        uint256 _deadline,\n        BountyCategory _category\n    ) external payable {\n        require(msg.value > 0, \"Stake amount must be greater than 0\");\n        require(_deadline > block.timestamp, \"Deadline must be in the future\");\n        require(bytes(_description).length > 0, \"Description cannot be empty\");\n        require(uint8(_category) <= 5, \"Invalid category\");\n\n        bountyCounter++;\n        uint256 bountyId = bountyCounter;\n\n        bounties[bountyId] = Bounty({\n            id: bountyId,\n            creator: msg.sender,\n            stakeAmount: msg.value,\n            deadline: _deadline,\n            description: _description,\n            category: _category,\n            isActive: true,\n            isClosed: false,\n            totalSubmissions: 0\n        });\n\n        // Add to category mapping\n        bountiesByCategory[_category].push(bountyId);\n\n        emit BountyCreated(bountyId, msg.sender, msg.value, _deadline, _description, _category);\n    }\n\n    /**\n     * @dev Submit work for a bounty\n     * @param _bountyId ID of the bounty\n     * @param _submissionLink Link to the submission (required)\n     * @param _tweetLink Tweet link (optional, can be empty)\n     * @param _githubLink GitHub repository link (required)\n     * @param _twitterLink Project Twitter link (required)\n     * @param _videoLink Video trailer link (required)\n     * @param _indieFunLink Indie.fun page link (required)\n     * @param _projectLink Live project link (optional, can be empty)\n     */\n    function submitWork(\n        uint256 _bountyId,\n        string memory _submissionLink,\n        string memory _tweetLink,\n        string memory _githubLink,\n        string memory _twitterLink,\n        string memory _videoLink,\n        string memory _indieFunLink,\n        string memory _projectLink\n    ) external bountyExists(_bountyId) bountyIsActive(_bountyId) {\n        require(!hasSubmitted[_bountyId][msg.sender], \"You have already submitted work for this bounty\");\n        require(bytes(_submissionLink).length > 0, \"Submission link cannot be empty\");\n        require(bytes(_githubLink).length > 0, \"GitHub link cannot be empty\");\n        require(bytes(_twitterLink).length > 0, \"Twitter link cannot be empty\");\n        require(bytes(_videoLink).length > 0, \"Video link cannot be empty\");\n        require(bytes(_indieFunLink).length > 0, \"Indie.fun link cannot be empty\");\n        require(\n            msg.sender != bounties[_bountyId].creator,\n            \"Bounty creator cannot submit work\"\n        );\n\n        uint256 submissionId = submissionCounters[_bountyId];\n        submissionCounters[_bountyId]++;\n\n        submissions[_bountyId][submissionId] = Submission({\n            bountyId: _bountyId,\n            submitter: msg.sender,\n            submissionLink: _submissionLink,\n            tweetLink: _tweetLink,\n            githubLink: _githubLink,\n            twitterLink: _twitterLink,\n            videoLink: _videoLink,\n            indieFunLink: _indieFunLink,\n            projectLink: _projectLink,\n            submissionTime: block.timestamp,\n            isWinner: false,\n            rank: 0\n        });\n\n        bounties[_bountyId].totalSubmissions++;\n        hasSubmitted[_bountyId][msg.sender] = true;\n\n        emit WorkSubmitted(\n            _bountyId,\n            submissionId,\n            msg.sender,\n            _submissionLink,\n            _githubLink,\n            _twitterLink,\n            _videoLink,\n            _indieFunLink\n        );\n    }\n\n    /**\n     * @dev Select winners and distribute prizes\n     * @param _bountyId ID of the bounty\n     * @param _submissionIds Array of submission IDs to select as winners\n     * @param _ranks Array of ranks (1, 2, 3) corresponding to each winner\n     * @param _prizeDistribution Array of prize percentages (in basis points, e.g., 5000 = 50%)\n     */\n    function selectWinners(\n        uint256 _bountyId,\n        uint256[] memory _submissionIds,\n        uint8[] memory _ranks,\n        uint256[] memory _prizeDistribution\n    ) external onlyBountyCreator(_bountyId) bountyExists(_bountyId) deadlinePassed(_bountyId) {\n        Bounty storage bounty = bounties[_bountyId];\n        require(!bounty.isClosed, \"Bounty is already closed\");\n        require(\n            _submissionIds.length == _ranks.length && _ranks.length == _prizeDistribution.length,\n            \"Arrays must have the same length\"\n        );\n        require(_submissionIds.length > 0, \"At least one winner must be selected\");\n        require(_submissionIds.length <= 3, \"Maximum 3 winners allowed\");\n\n        _validateWinnersInput(_ranks, _prizeDistribution);\n        _distributePrizes(_bountyId, _submissionIds, _ranks, _prizeDistribution, bounty.stakeAmount);\n\n        // Close the bounty\n        bounty.isClosed = true;\n        bounty.isActive = false;\n\n        emit BountyClosed(_bountyId, msg.sender);\n    }\n\n    /**\n     * @dev Internal function to validate winners input\n     */\n    function _validateWinnersInput(\n        uint8[] memory _ranks,\n        uint256[] memory _prizeDistribution\n    ) internal pure {\n        // Validate ranks are 1, 2, or 3\n        for (uint256 i = 0; i < _ranks.length; i++) {\n            require(_ranks[i] >= 1 && _ranks[i] <= 3, \"Rank must be between 1 and 3\");\n        }\n\n        // Validate prize distribution sums to 100% (10000 basis points)\n        uint256 totalDistribution = 0;\n        for (uint256 i = 0; i < _prizeDistribution.length; i++) {\n            totalDistribution += _prizeDistribution[i];\n        }\n        require(totalDistribution == 10000, \"Prize distribution must sum to 100%\");\n    }\n\n    /**\n     * @dev Internal function to distribute prizes to winners\n     */\n    function _distributePrizes(\n        uint256 _bountyId,\n        uint256[] memory _submissionIds,\n        uint8[] memory _ranks,\n        uint256[] memory _prizeDistribution,\n        uint256 _stakeAmount\n    ) internal {\n        // Clear previous winners if any\n        delete winners[_bountyId];\n\n        address[] memory winnerAddresses = new address[](_submissionIds.length);\n        uint256[] memory prizeAmounts = new uint256[](_submissionIds.length);\n\n        // Process each winner\n        for (uint256 i = 0; i < _submissionIds.length; i++) {\n            uint256 submissionId = _submissionIds[i];\n            Submission storage submission = submissions[_bountyId][submissionId];\n            \n            require(submission.submitter != address(0), \"Invalid submission ID\");\n            require(!submission.isWinner, \"Submission already selected as winner\");\n\n            // Calculate prize amount\n            uint256 prizeAmount = (_stakeAmount * _prizeDistribution[i]) / 10000;\n\n            // Mark as winner\n            submission.isWinner = true;\n            submission.rank = _ranks[i];\n\n            address winnerAddress = submission.submitter;\n            uint8 rank = _ranks[i];\n\n            // Store winner info\n            winners[_bountyId].push(Winner({\n                winner: winnerAddress,\n                rank: rank,\n                prizeAmount: prizeAmount\n            }));\n\n            winnerAddresses[i] = winnerAddress;\n            prizeAmounts[i] = prizeAmount;\n\n            // Transfer prize to winner\n            (bool success, ) = payable(winnerAddress).call{value: prizeAmount}(\"\");\n            require(success, \"Prize transfer failed\");\n\n            emit PrizeDistributed(_bountyId, winnerAddress, rank, prizeAmount);\n        }\n\n        emit WinnersSelected(_bountyId, winnerAddresses, _ranks, prizeAmounts);\n    }\n\n    /**\n     * @dev Refund bounty creator if no submissions were made (after deadline)\n     * @param _bountyId ID of the bounty\n     */\n    function refundBounty(uint256 _bountyId) external onlyBountyCreator(_bountyId) bountyExists(_bountyId) deadlinePassed(_bountyId) {\n        Bounty storage bounty = bounties[_bountyId];\n        require(!bounty.isClosed, \"Bounty is already closed\");\n        require(bounty.totalSubmissions == 0, \"Cannot refund: submissions exist\");\n\n        bounty.isClosed = true;\n        bounty.isActive = false;\n\n        (bool success, ) = payable(msg.sender).call{value: bounty.stakeAmount}(\"\");\n        require(success, \"Refund transfer failed\");\n\n        emit BountyClosed(_bountyId, msg.sender);\n    }\n\n    /**\n     * @dev Cancel bounty and refund creator if not satisfied with submissions (after deadline)\n     * @param _bountyId ID of the bounty\n     * @param _reason Reason for cancellation (optional)\n     */\n    function cancelBounty(\n        uint256 _bountyId,\n        string memory _reason\n    ) external onlyBountyCreator(_bountyId) bountyExists(_bountyId) deadlinePassed(_bountyId) {\n        Bounty storage bounty = bounties[_bountyId];\n        require(!bounty.isClosed, \"Bounty is already closed\");\n        require(bounty.totalSubmissions > 0, \"Use refundBounty() if no submissions exist\");\n        \n        // Check if winners have already been selected\n        require(winners[_bountyId].length == 0, \"Cannot cancel: winners have already been selected\");\n\n        uint256 refundAmount = bounty.stakeAmount;\n        \n        // Close the bounty\n        bounty.isClosed = true;\n        bounty.isActive = false;\n\n        // Refund the creator\n        (bool success, ) = payable(msg.sender).call{value: refundAmount}(\"\");\n        require(success, \"Refund transfer failed\");\n\n        emit BountyCancelled(_bountyId, msg.sender, _reason);\n        emit BountyClosed(_bountyId, msg.sender);\n    }\n\n    /**\n     * @dev Get bounty details\n     * @param _bountyId ID of the bounty\n     */\n    function getBounty(uint256 _bountyId) external view returns (Bounty memory) {\n        return bounties[_bountyId];\n    }\n\n    /**\n     * @dev Get submission details\n     * @param _bountyId ID of the bounty\n     * @param _submissionId ID of the submission\n     */\n    function getSubmission(\n        uint256 _bountyId,\n        uint256 _submissionId\n    ) external view returns (Submission memory) {\n        return submissions[_bountyId][_submissionId];\n    }\n\n    /**\n     * @dev Get all winners for a bounty\n     * @param _bountyId ID of the bounty\n     */\n    function getWinners(uint256 _bountyId) external view returns (Winner[] memory) {\n        return winners[_bountyId];\n    }\n\n    /**\n     * @dev Get total number of submissions for a bounty\n     * @param _bountyId ID of the bounty\n     */\n    function getSubmissionCount(uint256 _bountyId) external view returns (uint256) {\n        return submissionCounters[_bountyId];\n    }\n\n    /**\n     * @dev Get contract balance\n     */\n    function getContractBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n\n    /**\n     * @dev Get all bounty IDs for a specific category\n     * @param _category The category to filter by\n     * @return Array of bounty IDs in the category\n     */\n    function getBountiesByCategory(BountyCategory _category) external view returns (uint256[] memory) {\n        return bountiesByCategory[_category];\n    }\n\n    /**\n     * @dev Get count of bounties in a specific category\n     * @param _category The category to count\n     * @return Number of bounties in the category\n     */\n    function getBountyCountByCategory(BountyCategory _category) external view returns (uint256) {\n        return bountiesByCategory[_category].length;\n    }\n\n    /**\n     * @dev Get active bounties by category\n     * @param _category The category to filter by\n     * @return Array of active bounty IDs in the category\n     */\n    function getActiveBountiesByCategory(BountyCategory _category) external view returns (uint256[] memory) {\n        uint256[] memory allBounties = bountiesByCategory[_category];\n        uint256 activeCount = 0;\n\n        // Count active bounties\n        for (uint256 i = 0; i < allBounties.length; i++) {\n            Bounty memory bounty = bounties[allBounties[i]];\n            if (bounty.isActive && !bounty.isClosed && block.timestamp < bounty.deadline) {\n                activeCount++;\n            }\n        }\n\n        // Create array with active bounties\n        uint256[] memory activeBounties = new uint256[](activeCount);\n        uint256 index = 0;\n        for (uint256 i = 0; i < allBounties.length; i++) {\n            Bounty memory bounty = bounties[allBounties[i]];\n            if (bounty.isActive && !bounty.isClosed && block.timestamp < bounty.deadline) {\n                activeBounties[index] = allBounties[i];\n                index++;\n            }\n        }\n\n        return activeBounties;\n    }\n}\n\n"
      }
    }
  }
}